package postgre

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"database/sql"
	"errors"
	"log/slog"
	"strconv"

	"github.com/Futturi/ozst"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, commentsAllowed bool) (*ozst.Post, error) {
	var id int64
	row := r.Db.QueryRow("INSERT INTO posts (title, content, commentsAllowed) VALUES ($1, $2, $3) RETURNING id", title, content, commentsAllowed)
	if err := row.Scan(&id); err != nil {
		return &ozst.Post{}, err
	}
	slog.Info("created post with id", "id", id)
	return &ozst.Post{ID: strconv.FormatInt(id, 10), Title: title, Content: content, CommentsAllowed: commentsAllowed}, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, content string) (*ozst.Comment, error) {
	if len(content) > maxCommentLength {
		slog.Info("error with message len")
		return nil, errors.New("comment content exceeds maximum length")
	}
	var allowed bool
	query := "SELECT commentsAllowed FROM posts WHERE id = $1"
	row1 := r.Db.QueryRow(query, postID)
	if err := row1.Scan(&allowed); err != nil {
		slog.Error("err with allow parametr", "error", err)
		return nil, err
	}
	if !allowed {
		slog.Info("comm are not allowed in this post")
		return nil, errors.New("comments are blocked in this post")
	}
	var pid interface{}
	if parentID != nil {
		pid = *parentID
	} else {
		pid = nil
	}

	row := r.Db.QueryRow("INSERT INTO comments (postId, parentId, content) VALUES ($1, $2, $3) RETURNING id", postID, pid, content)
	var id int64
	if err := row.Scan(&id); err != nil {
		slog.Error("error with parsing id", "error", err)
		return nil, err
	}
	slog.Info("created comment with id: ", "id", id)
	return &ozst.Comment{ID: strconv.FormatInt(id, 10), PostID: postID, ParentID: parentID, Content: content}, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, page int) ([]*ozst.Post, error) {
	rows, err := r.Db.Query("SELECT id, title, content, commentsAllowed FROM posts LIMIT $1 OFFSET $2", pageLen, pageLen*(page-1))
	if err != nil {
		slog.Error("error with rows", "error", err)
		return nil, err
	}
	defer rows.Close()

	var posts []*ozst.Post
	for rows.Next() {
		var post ozst.Post
		if err := rows.Scan(&post.ID, &post.Title, &post.Content, &post.CommentsAllowed); err != nil {
			slog.Error("error with parsing parameters", "error", err)
			return nil, err
		}
		var comment []ozst.Comment
		newcom := make([]*ozst.Comment, 0)
		query := "SELECT id, postId, parentId, content FROM comments WHERE postId = $1"
		if err = r.Db.Select(&comment, query, post.ID); err != nil {
			slog.Error("error with query", err)
			return nil, err
		}
		for _, com := range comment {
			b, err := r.recur(com.ID)
			if err != nil {
				slog.Error("error", "error", err)
				return nil, err
			}
			newcom = append(newcom, &ozst.Comment{
				ID:       com.ID,
				PostID:   com.PostID,
				ParentID: com.ParentID,
				Content:  com.Content,
				Children: b,
			})
		}
		post.Comments = newcom
		posts = append(posts, &post)
	}
	start := (page - 1) * pageLen // 1 запись
	end := page * pageLen
	for _, post := range posts {
		if end > len(post.Comments) {
			end = len(post.Comments)
		}
		if start > len(post.Comments) {
			post.Comments = []*ozst.Comment{}
		} else {
			post.Comments = post.Comments[start:end]
		}
	}
	slog.Info("get posts")
	return posts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string, page int) (*ozst.Post, error) {
	row := r.Db.QueryRow("SELECT id, title, content, commentsAllowed FROM posts WHERE id = $1", id)
	var post ozst.Post
	if err := row.Scan(&post.ID, &post.Title, &post.Content, &post.CommentsAllowed); err != nil {
		if err == sql.ErrNoRows {
			slog.Info("no messages with this id: ", "id", id)
			return nil, nil
		}
		return nil, err
	}
	var comment []ozst.Comment
	newcom := make([]*ozst.Comment, 0)
	query := "SELECT id, postId, parentId, content FROM comments WHERE postId = $1"
	if err := r.Db.Select(&comment, query, post.ID); err != nil {
		slog.Error("error with query", "error", err)
		return nil, err
	}
	for _, com := range comment {
		if com.ParentID != nil {
			continue
		}
		b, err := r.recur(com.ID)
		if err != nil {
			slog.Error("error", "errror", err)
			return nil, err
		}
		newcom = append(newcom, &ozst.Comment{
			ID:       com.ID,
			PostID:   com.PostID,
			ParentID: com.ParentID,
			Content:  com.Content,
			Children: b,
		})
	}
	post.Comments = newcom
	start := (page - 1) * pageLen // 1 запись
	end := page * pageLen
	if end > len(post.Comments) {
		end = len(post.Comments)
	}
	if start > len(post.Comments) {
		post.Comments = []*ozst.Comment{}
	} else {
		post.Comments = post.Comments[start:end]
	}
	slog.Info("get post by id")
	return &post, nil
}

// Mutation returns ozst.MutationResolver implementation.
func (r *Resolver) Mutation() ozst.MutationResolver { return &mutationResolver{r} }

// Query returns ozst.QueryResolver implementation.
func (r *Resolver) Query() ozst.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
